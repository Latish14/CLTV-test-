# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UihI2t67DwHd9UErb51B3PQuqOTjoC4d
"""

!pip install streamlit
!pip install lifetimes

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

from lifetimes import BetaGeoFitter, GammaGammaFitter
from lifetimes.utils import summary_data_from_transaction_data, calibration_and_holdout_data

st.set_page_config(page_title="CLV Predictor", layout="wide")
st.title("📊 Customer Lifetime Value (CLV) Predictor")

uploaded_file = st.file_uploader("Upload transaction CSV file", type=["csv"])

if uploaded_file:
    try:
        df = pd.read_csv(uploaded_file, encoding='latin-1')

        # Preprocessing
        df.dropna(subset=['CustomerID', 'InvoiceDate', 'Quantity', 'UnitPrice'], inplace=True)
        df.drop_duplicates(inplace=True)
        df = df[df['Quantity'] > 0]
        df = df[df['UnitPrice'] > 0]
        df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'], errors='coerce')
        df['CustomerID'] = df['CustomerID'].astype(int)
        df['TotalPrice'] = df['Quantity'] * df['UnitPrice']

        # Summarize transaction data
        summary = summary_data_from_transaction_data(df, 'CustomerID', 'InvoiceDate', 'TotalPrice')

        # Remove customers with no monetary value (required by Gamma-Gamma model)
        summary = summary[summary['monetary_value'].notnull() & (summary['monetary_value'] > 0)]

        # Modeling
        bgf = BetaGeoFitter(penalizer_coef=0.1)
        bgf.fit(summary['frequency'], summary['recency'], summary['T'])

        ggf = GammaGammaFitter(penalizer_coef=0.0)
        ggf.fit(summary['frequency'], summary['monetary_value'])

        # Predictions with NaN-safe conversion
        predicted_purchases = bgf.conditional_expected_number_of_purchases_up_to_time(
            90, summary['frequency'], summary['recency'], summary['T']
        )
        summary['predicted_purchases'] = predicted_purchases.fillna(0).round().astype(int)

        summary['predicted_monetary'] = ggf.conditional_expected_average_profit(
            summary['frequency'], summary['monetary_value']
        ).fillna(0)

        summary['CLV'] = ggf.customer_lifetime_value(
            bgf, summary['frequency'], summary['recency'],
            summary['T'], summary['monetary_value'], time=24, discount_rate=0.0
        ).fillna(0)

        # Show predictions
        st.subheader("CLV Predictions Table")
        st.write(summary[['predicted_purchases', 'predicted_monetary', 'CLV']].head(10))

        # Plotting
        st.subheader("CLV Distribution Plot")
        clv_filtered = summary[summary['CLV'] < 10000]['CLV']
        p25, p50, p75 = np.percentile(clv_filtered, [25, 50, 75])

        fig, ax = plt.subplots(figsize=(10, 6))
        sns.histplot(clv_filtered, bins=50, kde=True, color='skyblue')
        plt.axvline(p25, color='green', linestyle='--', label=f'25th %ile: {p25:.0f}')
        plt.axvline(p50, color='blue', linestyle='--', label=f'50th %ile: {p50:.0f} (Median)')
        plt.axvline(p75, color='red', linestyle='--', label=f'75th %ile: {p75:.0f}')
        plt.legend()
        ax.set_title("CLV Distribution")
        st.pyplot(fig)

        # Optional Calibration Output
        if st.checkbox("Show calibration/holdout summary"):
            calib_holdout = calibration_and_holdout_data(df, 'CustomerID', 'InvoiceDate',
                                                        observation_period_end=df['InvoiceDate'].min() + pd.Timedelta(days=180),
                                                        monetary_value_col='TotalPrice')
            st.write("Calibration/Holdout Summary:")
            st.write(calib_holdout.head())

    except Exception as e:
        st.error(f"⚠️ Error: {e}")